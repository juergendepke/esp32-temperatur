<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Outback Temperatur</title>
<link rel="manifest" href="manifest.json">
<style>
body {
  font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif;
  text-align: center;
  background: #f5f5f7;
  color: #1c1c1e;
  margin: 0;
  padding: 2rem;
}
h1 {
  font-size: 1.8rem;
  margin-bottom: 1rem;
}
button {
  background-color: #007aff;
  color: white;
  border: none;
  border-radius: 12px;
  padding: 12px 20px;
  font-size: 1.1rem;
  margin: 0.5rem;
}
input[type=number] {
  border: 1px solid #ccc;
  border-radius: 10px;
  padding: 8px;
  width: 80px;
  font-size: 1rem;
}
#log {
  margin-top: 20px;
  font-size: 0.9rem;
  max-height: 200px;
  overflow-y: auto;
  text-align: left;
  background: white;
  border-radius: 12px;
  padding: 1rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
</style>
</head>
<body>
<h1>üå°Ô∏è Outback Temperatur</h1>
<button id="connectBtn">üîó Verbinden</button>
<p>Intervall: <input id="intervalInput" type="number" min="1" max="30" value="5"> s
<button id="setIntervalBtn">Setzen</button></p>
<h2 id="tempDisplay">--.- ¬∞C</h2>

<button id="exportBtn">üì§ CSV exportieren</button>
<div id="log"></div>

<script>
let device, server, tempChar, intervalChar;
let readings = [];

async function connectBLE() {
  try {
    device = await navigator.bluetooth.requestDevice({
      filters: [{ namePrefix: 'ESP32C3_TempSensor' }],
      optionalServices: ['12345678-1234-5678-1234-56789abcdef0']
    });
    const server = await device.gatt.connect();
    const service = await server.getPrimaryService('12345678-1234-5678-1234-56789abcdef0');
    tempChar = await service.getCharacteristic('12345678-1234-5678-1234-56789abcdef1');
    intervalChar = await service.getCharacteristic('12345678-1234-5678-1234-56789abcdef2');

    tempChar.startNotifications();
    tempChar.addEventListener('characteristicvaluechanged', handleTemperature);

    log('‚úÖ Verbunden.');
    wakeLock();
  } catch (error) {
    log('Fehler: ' + error);
  }
}

function handleTemperature(event) {
  const decoder = new TextDecoder();
  const value = decoder.decode(event.target.value);
  const timestamp = new Date().toLocaleTimeString();
  document.getElementById('tempDisplay').innerText = value + ' ¬∞C';
  readings.push({ time: timestamp, temp: value });
  log(`${timestamp}: ${value} ¬∞C`);
}

async function setIntervalBLE() {
  const val = document.getElementById('intervalInput').value;
  if (intervalChar) {
    const encoder = new TextEncoder();
    await intervalChar.writeValue(encoder.encode(val));
    log(`‚è±Ô∏è Intervall auf ${val}s gesetzt`);
  }
}

function log(msg) {
  const el = document.getElementById('log');
  el.innerHTML += msg + '<br>';
  el.scrollTop = el.scrollHeight;
}

async function exportCSV() {
  let csv = "Zeit,Temperatur\n";
  readings.forEach(r => csv += `${r.time},${r.temp}\n`);
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  window.location.href = `mailto:?subject=Temperaturdaten&body=CSV%20angeh√§ngt.&attachment=${url}`;
}

async function wakeLock() {
  try {
    const lock = await navigator.wakeLock.request('screen');
    log('üì± Bildschirm bleibt an');
  } catch (err) {
    log('WakeLock nicht unterst√ºtzt: ' + err);
  }
}

document.getElementById('connectBtn').addEventListener('click', connectBLE);
document.getElementById('setIntervalBtn').addEventListener('click', setIntervalBLE);
document.getElementById('exportBtn').addEventListener('click', exportCSV);
</script>
</body>
</html>
